---
title: "Gene Finding II"
teaching: 
exercises: 180
questions:
objectives:
- "Predict ORFs in viral contigs with Phanotate"
- "Compare gene annotations of Phanotate and CheckV (prodigal-gv)"
- "Intersect coordinates with BEDtools"
- "Reflect on applications of different annotation tools"
keypoints:
- "Knowing how Phanotate works in theory allows a better interpretation of your results"
- "Comparing the results of Phanotate and prodigal-gv shows you that different tools produce different results. Therefore it is important to choose an appropriate tool for your data."
---

# Gene Finding

After assembling viral contigs and filtering the phage ones, you will be working with gene annotation. You have actually already done an annotation to your viral contigs when you ran [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/). In its internal pipeline, CheckV uses [prodigal-gv](https://github.com/apcamargo/prodigal-gv) for gene calling. To complement prodigal-gv, you will do a second annotation with [Phanotate](https://github.com/deprekate/PHANOTATE). Afterwards you will compare the two results. To start, check the webpages of the two tools and answer the questions below.  

> ## challenge
>
> Describe the file format that was produced by CheckV/prodigal-gv and show its header with bash (```head <file>```).
> 
> Which file formats can Phanotate produce? Which one is the most similar to the one produced by prodigal-gv/CheckV?
>
> Describe the difference between Phanotate's algorithm and prodigal-gv's.
>
> Do you expect to find more hits with prodigal-gv or Phanotate? Why?
> 
> {: .source}
{: .discussion}

Now, we ask you to produce two different outputs with Phanotate: one GFF containing the ORF coordinates and one FASTA containing the corresponding aminoacid sequences. Create sbatch scripts for running Phanotate. Note that the tool will require almost 6 GB memory, so make sure you adapt your sbatch file.

> ## exercise
>
> Run Phanotate for your viral contigs to produce a GFF file and a FASTA file:
> 
>```bash
> source /home/groups/VEO/tools/phanotate/v1.5.0/myenv/bin/activate
> phanotate.py <input> -o <output.gff> -f gff
> phanotate.py <input> -o <output.faa> -f faa
>```
>
> Inspect the output and interpret it following the tool's webpage
>   
>```bash
> head <output>
>```
> {: .source}
{: .challenge}

Next, answer the following question in your lab book. Try to come up with a command yourself for answering the question. If not possible, use the solution below.

> ## challenge
> 
> How many ORFs did Phanotate predict per contig? You do not need to show the result for every contig, just show the command you used and a small sample of your results.
> 
> {: .source}
{: .discussion}

> ## bash command for number of ORFs per contig
> ```bash
> grep -v '#' <phage_contigs.gff> | cut -f1 | uniq -c > <output>
> head <output>
>```
> {: .source}
{: .solution}

# Choosing a contig

After running the tool, choose one phage contig to work with as an example. This way you can get more in depth in subsequent analysis. Choose a contig with 100% completeness and less than 5% contamination (these measures have already been calculated in the previous lecture [Assembly and cross-assembly](https://mgxlab.github.io/Viromics2024/1.2.2_assembly_and_cross-assembly/index.html)). Select Phanotate's predictions for that specific contig_id (gff and fasta) and save them to new files. Write a code for that if possible. If not, use the solutions below. Similarly, save the gff annotations of CheckV's prodigal-gv to a new file. We will need it to compare the annotations of Phanotate and prodigal-gv.        

> ## bash commands for finding complete phage contigs
> ```bash
> #print 20 lines of checkv's quality summary file sorted by completeness  
> cat <checkv_quality_summary.tsv> | sort -k 10 -nr | head -n 20
> #select by hand a few good contigs
> #check if the contigs you selected by hand were annotated by Jaeger to be phage and choose one to be your example
> grep -P '<contig_id>\t' <phage_contigs_after_selection.fasta>
>```
> {: .source}
{: .solution}

> ## bash command for saving contig files
> ```bash
> grep -P '<contig_id>\t' <output_Phanotate> > <contig_id_Phanotate.gff>
> grep -P '<contig_id>\t' <output_prodigal-gv> > <contig_id_prodigal-gv.gff>
>```
> {: .source}
{: .solution}

# Tools comparison

Phanotate has a different internal approach than CheckV's [prodigal-gv](https://github.com/apcamargo/prodigal-gv). While Phanotate is more broad and predicts all possible ORFs using a graph approach, prodigal-gv predicts genes based on their properties. So, we expect to see differences. It will be interesting to compare the outputs of the two tools.  

Next, answer the following questions in your lab book. If you are an experienced programmer, develop scripts locally in your laptop first and afterwards run it in draco using sbatch scripts. If you are not an experienced programmer, you could use the codes provided below.  

> ## challenge
> 
> How many ORFs did Phanotate predict for the contig you chose as an example?
>
> How many ORFs did prodigal-gv predict for this contig?
>
> Do you expect all annotations to be real biological structures? Why/why not?
>
> What is the longest ORF for this contig per tool?
>
> Do the predicted elements overlap in the contig?
> 
> {: .source}
{: .discussion}

> ## bash command for number of ORFs per contig
> ```bash
> wc -l <contig_id.gff> 
>```
> {: .source}
{: .solution}

> ## bash command for longest ORF
> ```bash
> #The same command should be valid for prodigal-gv's output, just adjust the column numbers
> #For Phanotate, the end and start columns are 5 and 4
> #For prodigal-gv, end and start columns are 4 and 3
> awk '{print $5 - $4}' <contig_id_Phanotate.gff> | sort -nr | head
>```
> {: .source}
{: .solution}

> ## check for overlapping ORFs
> You could write a script for that, if you want to precise.
> 
> Alternatively, you could check the files by hand, just looking at them with ```more <file>``` and checking if any start coordinate is smaller than a previous end coordinate. Many times, just looking at files and understanding them by yourself yields many clues about the data!
> {: .source}
{: .solution}

Considering the results you produced so far, reflect on the discussion below.

> ## challenge
> 
> Think about scenarios for which using one tool or the other would be more useful. In other words: which case could favor using prodigal-gv and which Phanotate?
> 
> {: .source}
{: .discussion}

# Coordinates comparison

Next, look for elements that were predicted by both tools and elements that were only predicted by one tool. For this you can directly compare coordinates using [BEDtools intersectBed](https://bedtools.readthedocs.io/en/latest/content/tools/intersect.html).   

> ## challenge
> 
> What does intersectBed does?
> 
> {: .source}
{: .discussion}

You may have noticed that the direct outputs of Phanotate and prodigal-gv do not match directly. To be able to compare the two annotation files with intersectBed, we should make both the files the same format. To do that, make sure that the same columns correspond to start, end, strand and contig_id. Do that using the command below adapt the format of the prodigal-gv file (alternatively, do the task in your own way).

```bash
awk 'BEGIN { OFS="\t" } { $2="None\t"$2; $5=".\t"$5; print }' <contig_if-prodigal-gv.gff> | sed 's/\t1\t/\t\+\t/g' | sed 's/\t-1\t/\t-\t/g' > <contig_id-prodigal-gv_formatted.gff>
```

To make sure everything worked as you intended, inspect the original files, <contig.gff>, and the adapted prodigal-gv file. Use ```head <file>``` and notice the format change. Afterwards proceed with intersectBed to get the common elements and the unique ones per tool as indicated below:     

```bash
#Coordinates intersection to get the common elements and save them to a file
/home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> > <output>

#Same as above, but instead of saving the result to a file, count the number of common elements
/home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> | wc -l

#Same as above, but changing the arguments -f and -r
/home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> -f 1 -r

#Coordinates intersection to get unique elements of file -a (adapt the script to save to file or just get the number of elements as above)
/home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> -v
```

> ## challenge
>
> Explain the commands above for intersectBed argument by argument following the tool's website
>
> If instead of running the tool with the default 'minimum overlap', you wanted 100% minimum overlap, what command line would you run? (If you feel lost, check the tip below)
> 
> How many elements did the two tools predict with the exact same coordinates (100% reciprocal minimum overlap)?
>
> How many elements of Phanotate did not overlap with elements of prodigal-gv and vice-versa?
> 
> {: .source}
{: .discussion}

> ## changing minimum overlap
> Check the website for arguments -f, -F and -r
> {: .source}
{: .solution}
