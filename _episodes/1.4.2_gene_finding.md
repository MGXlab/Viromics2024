---
title: "Genome annotation: hands-on"
teaching: 
exercises: 180
questions:
objectives:
- "Predict ORFs in viral contigs with Phanotate"
- "Compare gene annotations of Phanotate and CheckV (prodigal-gv)"
- "Intersect coordinates with BEDtools"
- "Reflect on applications of different annotation tools"
keypoints:
- "Knowing the theory behind tools like Phanotate allows for a better interpretation of your results"
- "Comparing two sets of annotations is useful and intersectBED is a versatile tool for that"
- "Comparing the annotations of Phanotate and prodigal-gv shows you that different tools produce different results. Therefore it is important to choose an appropriate tool for your data"
---

After assembling viral contigs and identifying the ones belonging to phages, we will annotate the genes. You have actually already done an annotation to your viral contigs when you ran [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/). In its internal pipeline, CheckV uses [prodigal-gv](https://github.com/apcamargo/prodigal-gv) for gene calling. To complement prodigal-gv, you will do a second annotation with [Phanotate](https://github.com/deprekate/PHANOTATE). Afterwards you will compare the two results. To start, check the webpages of the two tools and answer the questions below.

> ## Questions
>
> 1. Describe the file format that was produced by CheckV/prodigal-gv and look at the first 10 lines (```head <file>```).
> 
> 2. Which file formats can Phanotate produce? Which one is the most similar to the one produced by prodigal-gv/CheckV?
> 
> 3. Describe the difference between the algorithms of Phanotate and prodigal-gv.
> 
> 4. Which tool do you expect will find more genes, prodigal-gv or Phanotate? Why?
> 
> {: .source}
{: .discussion}

Now, we ask you to produce two different outputs with Phanotate: one GFF file containing the ORF coordinates, and one FASTA file containing the corresponding amino acid sequences.
Create sbatch scripts for running Phanotate. Note that the tool will require almost 6 GB of memory, so make sure to adapt your sbatch file. 

> ## Exercise
>
> Run Phanotate for your viral contigs to produce a GFF file and a FASTA file:
> 
>```bash
> source /home/groups/VEO/tools/phanotate/v1.5.0/myenv/bin/activate
> phanotate.py <input> -o <output.gff> -f gff
> phanotate.py <input> -o <output.faa> -f faa
>```
>
> Inspect the output and interpret it following the tool's webpage.
>   
>```bash
> head <output>
>```
> {: .source}
{: .challenge}

For the following question, try to come up with a command yourself first. Only if you cannot figure it out, use the solution below.

> ## Question
> 
> 5. How many ORFs did Phanotate predict per contig? You do not need to show the result for every contig, just show the command you used and a small sample of your results.
> 
> {: .source}
{: .discussion}

> ## bash command for number of ORFs per contig
> ```bash
> grep -v '#' <phage_contigs.gff> | cut -f1 | uniq -c > <output>
> head <output>
>```
> {: .source}
{: .solution}

# Choosing a pet contig

After running Phanotate, choose one phage contig to work with as an example, this will be your pet phage with which you will perform in-depth follow-up analyses. 
Choose a contig with 100% completeness and <5% contamination (these measures have already been calculated in the section [Assembly and cross-assembly](https://mgxlab.github.io/Viromics2024/1.2.2_assembly_and_cross-assembly/index.html)). 
Select Phanotate's predictions for that specific contig_id (GFF and FASTA) and save them to new files. Write code for that if possible, else use the solutions below. 
Similarly, save the GFF annotations of CheckV's prodigal-gv to a new file. We will need it to compare the annotations of Phanotate and prodigal-gv.

> ## bash commands for finding complete phage contigs
> ```bash
> #print 20 lines of CheckV's quality summary file sorted by completeness  
> cat <checkv_quality_summary.tsv> | sort -k 10 -nr | head -n 20
> #select by hand a few good contigs
> #check if the contigs you selected by hand were annotated by Jaeger to be phage and choose one to be your example
> grep -P '<contig_id>\t' <phage_contigs_after_selection.fasta>
>```
> {: .source}
{: .solution}

> ## bash command for saving contig files
> ```bash
> grep -P '<contig_id>\t' <output_Phanotate> > <contig_id_Phanotate.gff>
> grep -P '<contig_id>\t' <output_prodigal-gv> > <contig_id_prodigal-gv.gff>
>```
> {: .source}
{: .solution}

# Tools comparison

Phanotate has a different internal approach than CheckV's [prodigal-gv](https://github.com/apcamargo/prodigal-gv). 
While Phanotate is more broad and predicts all possible ORFs using a graph approach, prodigal-gv predicts genes based on their properties. 
So, we expect to see differences. It will be interesting to compare the outputs of the two tools.  

If you are an experienced programmer, write scripts to tackle the next questions. 
To make sure they work as expected, develop the scripts locally on your laptop before running them with sbatch on Draco. 
If you are not an experienced programmer, use the scripts provided below.

> ## Questions
> 
> 6. How many ORFs did Phanotate predict for the contig you chose as an example?
>
> 7. How many ORFs did prodigal-gv predict for this contig?
>
> 8. Do you expect all ORFs to be real protein-coding genes? Why (not)?
>
> 9. What is the longest ORF that each tool found on this contig?
>
> 10. Do the predicted ORFs overlap in the contig? 
> First check the files by hand, just looking at them with ```more <file>``` and checking if any start coordinate is smaller than a previous end coordinate. 
> While you should never trust your eye to be as accurate as a script, scrolling through files and trying to understand them can yield many clues/hypotheses about the data. 
> Then you can write a script based on what you saw, to check if your hypothesis holds on a large scale. 
>
> {: .source}
{: .discussion}

> ## bash command for number of ORFs per contig
> ```bash
> wc -l <contig_id.gff> 
>```
> {: .source}
{: .solution}

> ## bash command for longest ORF
> ```bash
> #The same command should be valid for prodigal-gv's output, just adjust the column numbers
> #For Phanotate, the end and start columns are 5 and 4
> #For prodigal-gv, end and start columns are 4 and 3
> awk '{print $5 - $4}' <contig_id_Phanotate.gff> | sort -nr | head
>```
> {: .source}
{: .solution}

> ## Question
> 
> 11. Considering the results you produced so far, think about scenarios for which using one tool or the other would be more useful. In other words: which case could favor using prodigal-gv and which case Phanotate?
> 
> {: .source}
{: .discussion}

# Comparing coordinates

Next, we will look for elements that were predicted by both tools and elements that were only predicted by one tool. 
You can directly compare coordinates using [BEDtools intersectBed](https://bedtools.readthedocs.io/en/latest/content/tools/intersect.html). 

> ## Question
> 
> 12. What does intersectBed do? 
> 
> {: .source}
{: .discussion}

You may have noticed that the output file formats of Phanotate and prodigal-gv do not entirely match. 
To compare the two annotation files with intersectBed, we should prepare both files in the same format. 
Ensure that the same columns correspond to start, end, strand, and contig_id. 
You could use the command below to adapt the format of the prodigal-gv file, or make your own script. 

```bash
awk 'BEGIN { OFS="\t" } { $2="None\t"$2; $5=".\t"$5; print }' <contig_if-prodigal-gv.gff> | sed 's/\t1\t/\t\+\t/g' | sed 's/\t-1\t/\t-\t/g' > <contig_id-prodigal-gv_formatted.gff>
```

To make sure everything worked as you intended, inspect the original files, <contig.gff>, and the adapted prodigal-gv file. 
Use ```head <file>``` and notice the format change. Afterwards, proceed with intersectBed to get the common elements and the unique ones per tool as indicated below:     

```bash
#Coordinates intersection to get the common elements and save them to a file
/home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> > <output>

#Same as above, but instead of saving the result to a file, count the number of common elements
/home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> | wc -l

#Same as above, but changing the arguments -f and -r
/home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> -f 1 -r

#Coordinates intersection to get unique elements of file -a (adapt the script to save to file or just get the number of elements as above)
/home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> -v
```

> ## Question
>
> 13. Explain the commands above for intersectBed argument by argument, following the tool's [website](https://bedtools.readthedocs.io/en/latest/content/tools/intersect.html).
>
> 14. If you wanted to run the tool with 100% overlap instead of the default 'minimum overlap' value, what command line options would you include? (If you feel lost, check the tip below.)
> 
> 15. How many elements did the two tools predict with the exact same coordinates (100% reciprocal minimum overlap)?
>
> 16. How many elements of Phanotate did not overlap with elements of prodigal-gv, and _vice versa_?
> 
> {: .source}
{: .discussion}

> ## changing minimum overlap
> Check the website for arguments -f, -F and -r
> {: .source}
{: .solution}
