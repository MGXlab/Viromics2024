---
title: "Gene Finding II"
teaching: 
exercises: 180
questions:
objectives:
- "Predict ORFs in viral contigs with Phanotate"
- "Compare gene annotations of Phanotate and CheckV (prodigal-gv)"
keypoints:
---

# Gene Finding

After assembling virome contigs and filtering the phage ones, you will be working with gene annotation. You have actually already done an annotation to your viral contigs when you ran [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/). In its internal pipeline, CheckV uses [prodigal-gv](https://github.com/apcamargo/prodigal-gv) for gene calling. To complement prodigal-gv, you will do a second annotation with [Phanotate](https://github.com/deprekate/PHANOTATE). Afterwards you will compare the two results. To start, check the webpages of the two tools and answer the questions below.  

> ## discussion
>
> Describe the file format that was produced by CheckV/prodigal-gv and show its header with bash (```head <file>```).
> 
> Which file formats can Phanotate produce? Which one is the most similar to the one produced by prodigal-gv/CheckV?
>
> Describe the difference between Phanotate's algorithm and prodigal-gv's.
>
> Do you expect to find more hits with prodigal-gv or Phanotate? Why?
> 
> {: .source}
{: .discussion}

Now, we ask you to produce two different outputs with Phanotate: one GFF containing the ORF coordinates and one FASTA containing the corresponding aminoacid sequences. Create sbatch scripts for running Phanotate. Note that the tool will require almost 6 GB memory, so make sure you adapt your sbatch file.

> ## exercise
>
> Run Phanotate for your viral contigs to produce a GFF file and a FASTA file:
> 
>```bash
> source /home/groups/VEO/tools/phanotate/v1.5.0/myenv/bin/activate
> phanotate.py <input> -o <output.gff> -f gff
> phanotate.py <input> -o <output.faa> -f faa
>```
>
> Inspect the output and interpret it following the tool's webpage
>   
>```bash
> head <output>
>```
> {: .source}
{: .challenge}

Next, answer the following questions in your lab book.

> ## discussion
> 
> How many ORFs did Phanotate predict per contig?
> 
> {: .source}
{: .discussion}

> ## bash command for number of ORFs per contig
> ```bash
> grep -v '#' <phage_contigs.gff> | cut -f1 | uniq -c > <output>
>```
> {: .source}
{: .solution}

# Choosing a contig

After running the tool, choose one phage contig to work with as an example. This way you can get more in depth in subsequent analysis. Choose a contig with 100% completeness and less than 5% contamination (these measures have already been calculated in the previous lecture [Identifying Viral Contigs II]([Assembly and cross-assembly](https://mgxlab.github.io/Viromics2024/1.2.2_assembly_and_cross-assembly/index.html))). Select Phanotate's predictions for that specific contig_id (gff and fasta) and save them to new files. Write a code for that if possible. If not, use the solutions below. Similarly, save the gff annotations of CheckV's prodigal-gv to a new file. We will need it to compare the annotations of Phanotate and prodigal-gv.        

> ## bash commands for finding complete phage contigs
> ```bash
> #print 20 lines of checkv_quality_summary.tsv sorted by completeness  
> cat <checkv_quality_summary.tsv> | sort -k 10 -nr | head -n 20
> #select by hand a few good contigs
> #check if the contigs you selected by hand were annotated by Jaeger to be phage
> grep -P '<contig_id>\t' <phage_contigs_after_selection.fasta>
>```
> {: .source}
{: .solution}

> ## bash command for saving contig files
> ```bash
> grep -P '<contig_id>\t' <output_Phanotate> > <contig_id_Phanotate.gff>
> grep -P '<contig_id>\t' <output_prodigal-gv> > <contig_id_prodigal-gv.gff>
>```
> {: .source}
{: .solution}

# Tools comparison

Phanotate has a different internal approach than CheckV's [prodigal-gv](https://github.com/apcamargo/prodigal-gv). While Phanotate is more broad and predicts all possible ORFs using a graph approach, prodigal-gv predicts genes based on their properties. So, we expect to see differences. It will be interesting to compare the outputs of the two tools.  

Next, answer the following questions in your lab book. If you are an experienced programmer, develop scripts locally in your laptop first and afterwards run it in draco using sbatch scripts. If you are not an experienced programmer, you could use the codes provided below.  

> ## discussion
> 
> How many ORFs did Phanotate predict for the contig you chose as an example?
>
> How many ORFs did prodigal-gv predict for this contig?
>
> Do you think all ORFs predicted by Phanotate are real biological structures?
> 
> What is the longest ORF for this contig per tool?
>
> Were there any overlapping ORFs in your contig?
> 
> {: .source}
{: .discussion}

> ## bash command for number of ORFs per contig
> ```bash
> grep -v '#' <contig_id_tool.gff> | cut -f1 | uniq -c 
>```
> {: .source}
{: .solution}

> ## bash command for longest ORF
> ```bash
> #The same command should be valid for prodigal-gv's output, just adjust the column numbers
> #For Phanotate, the end and start columns are 5 and 4
> #For prodigal-gv, end and start columns are 4 and 3
> awk '{print $5 - $4}' <contig_id_Phanotate.gff> | sort -nr | head
>```
> {: .source}
{: .solution}

> ## check for overlapping ORFs
> You could write a script for that, if you want to precise
> Alternatively, you could check the files by hand, just looking at them with ```more <file>``` and checking if any start coordinate is smaller than a previous end coordinate
> {: .source}
{: .solution}

Now, let's compare the coordinates of the two annotations with [BEDtools intersectBed](https://bedtools.readthedocs.io/en/latest/content/tools/intersect.html).   

> ## adapting file format
> ```bash
>  
> awk 'BEGIN { OFS="\t" } { $2="None\t"$2; $5=".\t"$5; print }' <contig_if-prodigal-gv.gff> | sed 's/\t1\t/\t\+\t/g' | sed 's/\t-1\t/\t-\t/g' > <contig_if-prodigal-gv_formatted.gff>
>```
> {: .source}

> ## getting coordinates intersection
> ```bash
>
> #Coordinates intersection
> /home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> -f 1 -r
> #Number of common exact coordinates between the two tools
> /home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> -f 1 -r | wc -l
> #Elements in tool *a* that do not overlap with the elements of tool *b*
> /home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> -v
> #Number of elements in tool *a* that do not overlap with the elements of tool *b*
> /home/groups/VEO/tools/bedtools2/v2.31.0/bin/intersectBed -a <input1> -b <input2> -v  | wc -l
>```
> {: .source}

> ## discussion
>
> Explain the commands above for intersectBed argument by argument following the tool's website
>
> If instead of getting 100% match, you wanted to get 90% match, what command line would you choose?
> 
> How many elements did the two tools predict with the exact same coordinates?
>
> How many elements in tool *a* did not overlap with the elements of tool *b*?
> 
> {: .source}
{: .discussion}

> ## changing the percentage of coordinates match of intersectBed
> This is a tip: check the website for arguments -f and -r
> {: .source}
{: .solution}
