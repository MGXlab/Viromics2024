---
title: "Assembly and cross-assembly"
teaching: 120
exercises: 30
questions:
- "many for sure"
objectives:
- "does this work?"
keypoints:
---

# Assembly and cross-assembly

*Sequence assembly* is the reconstruction of long contiguous genomic sequences (called *contigs* or *scaffolds*) from short sequencing reads. Before 2014, a common approach in metagenomics was to compare the short sequencing reads to the genomes of known organisms in the database (and some studies today still take this approach). However, recall that most of the sequences of a metavirome are unknown, meaning that they yield no matches when are compared to the databases. Because of this, we need of database-independent approaches to describe new viral sequences. As bioinformatic tools improved, sequence assembly enabled recovery of longer sequences of the metagenomic datasets. Having a longer sequence means having more information to classify it, so using metagenome assembly helps to characterize complex communities such as the gut microbiome.

In this lesson you will assemble the metavirome in two different ways using the tool [Flye](https://github.com/mikolmogorov/Flye) introduced in [this article](https://www.nature.com/articles/s41587-019-0072-8). Flye was designed to work well with noisy long reads and for metagenomic samples. Since you work on draco, everything even slightly computationally expensive will be run through slurm. Please organize all the following steps in one or more sbatch scripts as you learned yesterday. Since every tool needs different amounts of resources, it is recommended to have a single script per tool. All code snippets presented here assume that you put them in an adequate sbatch script and the respective necessary resources are mentioned in the comments or the descriptions.

### Cross-Assembly

In a cross-assembly, **multiple samples are combined and assembled together**, allowing for the discovery of shared sequence elements between the samples. If a virus (or other sequence element) is present in several samples, its sequencing reads from the different samples will be assembled together in one contig. After this we can know which contigs are present in which sample by mapping the sequencing reads from each sample to the cross-assembly.

You will perform a cross-assembly of the samples you started working with yesterday. To this end, you have to concatenate the sample files and run flye on the merged file. Gzipped files can be concatenated just like text files with the command line tool cat and flye is installed in a conda environment on draco:

~~~
# activate conda environment with flye installation
source /vast/groups/VEO/tools/miniconda3_2024/etc/profile.d/conda.sh && conda activate flye_v2.9.2

# merge the sequences
$ cat /path/to/*.fastq.gz > /path/to/all_samples.fastq.gz

# create a folder for the output cross-assembly
$ mkdir -p 10_results_assembly_flye/crossassembly

# complete the flye command. This is the computationally expensive part and profits from many cores (30 is a good number).
# The used memory should not exceed 20GB of RAM. 
$ flye --out-dir 10_results_assembly_flye/crossassembly ...
~~~
{: .language-bash}

[Here](https://github.com/mikolmogorov/Flye/blob/flye/docs/USAGE.md) you can find an overview over the possible parameters. Flye can be used for single-organism assemblies as well as metagenomic assemblies and your sequences were generated with the nanopore MinION platform and filtered to only contain high quality reads. Flye needs an estimate of the size of your metagenome, i.e. the combined length of the assembled contigs. There is no good way to accurately predict this if you do not know what's in your samples as in our case. How would you very roughly estimate this number?

After you finished your sbatch script with the ressource assignments and the completed commands, you can either run it directly or continue to expand it with the commands for the second approach described below. If you run it now, remember you can check the output of your script in the slurm log files which you can set with the sbatch parameters at the beginning of your script:

~~~
#SBATCH --output=10_results_assembly_flye/assembly_flye.slurm.%j.out
#SBATCH --error=10_results_assembly_flye/assembly_flye.slurm.%j.err
~~~
{: .language-bash}

Most often, the error output contains more than just errors and the corresponding file is the more informative one.

### Separate assemblies

The second approach consists on performing separate assemblies for each sample and merging the resulting contigs in the end. Note that if a species is present in several samples, this final set will contain multiple contigs representing the same sequence, each of them coming from one sample. Because of this, we will further de-replicate the final contigs to get representative sequences.

To run separate assemblies, you can adapt the flye command used for the crossassembly to take each sample file individually and output the assemblies in separate folders in 10_results_assembly_flye. For this you can run a for loop over the respective files:


Once the assemblies had finished, you will combine their scaffolds in a single file.
The identifier of a contig/scaffold from SPAdes has the following format (from the [SPAdes manual](https://cab.spbu.ru/files/release3.15.2/manual.html)): _>NODE_3_length_237403_cov_243.207_, where _3_ is the number of the contig/scaffold, _237403_ is the sequence length in nucleotides and _243.207_ is the k-mer coverage.
It might happen that 2 contigs from different samples' assemblies have the same identifier, and
recall from earlier this morning that
So, just in case, we will add the sample identifier at the beginning of the scaffolds identifiers
to make sure they are different between samples. Use the Python script `rename_scaffolds.py`
for this, which will create a `scaffolds_renamed.fasta` file for each sample's assembly. Then,
merge the results into `1_assemblies/separate_assemblies/all_samples_scaffolds.fasta`.

~~~
# download the python script
$ wget https://raw.githubusercontent.com/MGXlab/Viromics-Workshop-MGX/gh-pages/code/day1/rename_scaffolds.py

# include sample name in scaffolds names
$ python rename_scaffolds.py -d 1_assemblies/separate_assemblies

# merge renamed scaffolds
$ cat 1_assemblies/separate_assemblies/*/scaffolds_renamed.fasta > 1_assemblies/separate_assemblies/all_samples_scaffolds.fasta
~~~
{: .language-bash}

To de-replicate the scaffolds, you will cluster them at 95% Average Nucleotide Identify (ANI) over 85% of the length of the shorter sequence, cutoffs often used to cluster viral genomes at the species level. For further analysis, we will use the longest sequence of the cluster as a representative of it. Then, with this approach we are:

- Clustering complete viral genomes at the species level
- Clustering genome fragments along with very similar and longer sequences

Look at the [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/) website and follow the steps under _Rapid genome clustering based on pairwise ANI_ section to perform this clustering.

~~~


# create a blast database with all the scaffolds
$ makeblastdb ...

# compare the scaffolds all vs all using blastn
$ blastn ...

# download anicalc.py and aniclust.py scripts
$ wget https://raw.githubusercontent.com/MGXlab/Viromics-Workshop-MGX/gh-pages/code/day1/anicalc.py
$ wget https://raw.githubusercontent.com/MGXlab/Viromics-Workshop-MGX/gh-pages/code/day1/aniclust.py

# calculate pairwise ANI
$ python anicalc.py ...

# cluster scaffolds at 95% ANI and 85% aligned fraction of the shorter
$ python aniclust.py -o 1_assemblies/separate_assemblies/my_clusters.tsv ...
~~~
{: .language-bash}


The final output, called `my_clusters.tsv`, is a two-columns tabular file with the representative sequence of the cluster in the first column, and all the scaffolds that are part of the cluster in the second column. Using `cut` and its `-f` parameter to put all the representatives names in one file called `my_clusters_representatives.txt`. Then, use `seqtk subseq` to grab the sequences of the scaffolds listed in `my_clusters_representatives.txt` and save them to `my_clusters_representatives.fasta`.

~~~
# put the representatives names in 'my_clusters_representatives.txt'
$ cut ... > 1_assemblies/separate_assemblies/my_clusters_representatives.txt

# extract the representatives sequences using seqtk
$ seqtk subseq ... > 1_assemblies/separate_assemblies/my_clusters_representatives.fasta
~~~
{: .language-bash}

> ## Scaffolding in SPAdes
> Previously this morning you saw how, using paired-end reads information, contigs
> can be merged in scaffolds. However, we have been using the scaffolds during this  
> lesson.
> Identify a scaffold with clear evidence of merged contigs, and explain how is that
> possible if we are using single-end reads.
> > ## Solution
> > Not the solution, but a hint ;) check the [SPAdes manual](http://cab.spbu.ru/files/release3.15.3/manual.html)
> {: .solution}
{: .challenge}

