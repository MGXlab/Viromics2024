---
title: "Assembly and cross-assembly"
teaching: 120
exercises: 30
questions:
- "many for sure"
objectives:
- "does this work?"
keypoints:
---

# Assembly and cross-assembly

*Sequence assembly* is the reconstruction of long contiguous genomic sequences (called *contigs* or *scaffolds*) from short sequencing reads. Before 2014, a common approach in metagenomics was to compare the short sequencing reads to the genomes of known organisms in the database (and some studies today still take this approach). However, recall that most of the sequences of a metavirome are unknown, meaning that they yield no matches when are compared to the databases. Because of this, we need of database-independent approaches to describe new viral sequences. As bioinformatic tools improved, sequence assembly enabled recovery of longer sequences of the metagenomic datasets. Having a longer sequence means having more information to classify it, so using metagenome assembly helps to characterize complex communities such as the gut microbiome.

In this lesson you will assemble the metavirome in two different ways using the tool [Flye](https://github.com/mikolmogorov/Flye) introduced in [this article](https://www.nature.com/articles/s41587-019-0072-8). Flye was designed to work well with noisy long reads and for metagenomic samples. Since you work on draco, everything even slightly computationally expensive will be run through slurm. Please organize all the following steps in one or more sbatch scripts as you learned yesterday. Since every tool needs different amounts of resources, it is recommended to have a single script per tool. All code snippets presented here assume that you put them in an adequate sbatch script and the respective necessary resources are mentioned in the comments or the descriptions.

### Cross-Assembly

In a cross-assembly, **multiple samples are combined and assembled together**, allowing for the discovery of shared sequence elements between the samples. If a virus (or other sequence element) is present in several samples, its sequencing reads from the different samples will be assembled together in one contig. After this we can know which contigs are present in which sample by mapping the sequencing reads from each sample to the cross-assembly.

You will perform a cross-assembly of the samples you started working with yesterday. To this end, you have to concatenate the sample files and run flye on the merged file. Gzipped files can be concatenated just like text files with the command line tool cat and flye is installed in a conda environment on draco:

~~~
# activate conda environment with flye installation on draco
source /vast/groups/VEO/tools/miniconda3_2024/etc/profile.d/conda.sh && conda activate flye_v2.9.2

# merge the sequences
cat /path/to/*.fastq.gz > /path/to/all_samples.fastq.gz

# create a folder for the output cross-assembly
mkdir -p 10_results_assembly_flye/crossassembly

# complete the flye command. This is the computationally expensive part
# and profits from many cores (30 is a good number). The used memory should
# not exceed 20GB of RAM. 
flye --out-dir 10_results_assembly_flye/crossassembly ...
~~~
{: .language-bash}

[Here](https://github.com/mikolmogorov/Flye/blob/flye/docs/USAGE.md) you can find an overview over the possible parameters. Flye can be used for single-organism assemblies as well as metagenomic assemblies and your sequences were generated with the nanopore MinION platform and filtered to only contain high quality reads. Flye needs an estimate of the size of your metagenome, i.e. the combined length of the assembled contigs. There is no good way to accurately predict this if you do not know what's in your samples as in our case. How would you very roughly estimate this number?

After you finished your sbatch script with the ressource assignments and the completed commands, you can either run it directly or continue to expand it with the commands for the second approach described below. If you run it now, remember you can check the output of your script in the slurm log files which you can set with the sbatch parameters at the beginning of your script:

~~~
#SBATCH --output=10_results_assembly_flye/assembly_flye.slurm.%j.out
#SBATCH --error=10_results_assembly_flye/assembly_flye.slurm.%j.err
~~~
{: .language-bash}

Most often, the error output contains more than just errors and the corresponding file is the more informative one.

### Separate assemblies

The second approach consists on performing separate assemblies for each sample and merging the resulting contigs in the end. Note that if a species is present in several samples, this final set will contain multiple contigs representing the same sequence, each of them coming from one sample. Because of this, we will further de-replicate the final contigs to get representative sequences.

To run separate assemblies, you can adapt the flye command used for the crossassembly to take each sample file individually and output the assemblies in separate folders in 10_results_assembly_flye. For this you can run a for loop over the respective files. The following expects the sample files to be called barcodeN.fastq.gz with N in (62, 63, 64):

~~~
# The individual assemblies need less memory than the crossassembly,
# but you can still use the same resources as before.
for barcode in $(seq 62 64)
do
	flye ... /path/to/barcode$barcode.fastq.gz ...
done
~~~
{: .language-bash}

Here, the command seq generates a sequence of integer numbers between its two arguments. Once the assemblies have finished, you will combine the contigs generated for each sample into a single file. Since the generated contigs are only assigned numbers by flye (not necessarily sequential), the same names will be present in each assembly. We have to rename them according to the sample they originate from for all contigs to have unique names. We can do this using python and the Biopython package. Biopython provides many tools for the analysis of sequencing data, including tools for parsing and writing .fasta files. You can find the documentation on these [here](https://biopython.org/wiki/SeqIO).

~~~
# download the python script
$ wget https://raw.githubusercontent.com/MGXlab/Viromics-Workshop-MGX/gh-pages/code/day1/rename_scaffolds.py

# include sample name in scaffolds names
$ python rename_scaffolds.py -d 1_assemblies/separate_assemblies

# merge renamed scaffolds
$ cat 1_assemblies/separate_assemblies/*/scaffolds_renamed.fasta > 1_assemblies/separate_assemblies/all_samples_scaffolds.fasta
~~~
{: .language-bash}

To de-replicate the scaffolds, you will cluster them at 95% Average Nucleotide Identify (ANI) over 85% of the length of the shorter sequence, cutoffs often used to cluster viral genomes at the species level. This can be done with the tool [vClust](https://github.com/refresh-bio/vclust) and results in both,

- Clustering complete viral genomes at the species level
- Clustering genome fragments along with very similar and longer sequences

~~~
# vClust is a python script and can be run by simply calling it on draco
# you have to run it with python 3.9
vclust='python3.9 /home/groups/VEO/tools/vclust/v1.0.3/vclust.py'

$vclust prefilter -i 10_results_assembly_flye/crossassembly/assembly.fasta ...
$vclust align ...
$vclust cluster ...
~~~
{: .language-bash}


The final output, called `my_clusters.tsv`, is a two-columns tabular file with the representative sequence of the cluster in the first column, and all the scaffolds that are part of the cluster in the second column. Using `cut` and its `-f` parameter to put all the representatives names in one file called `my_clusters_representatives.txt`. Then, use `seqtk subseq` to grab the sequences of the scaffolds listed in `my_clusters_representatives.txt` and save them to `my_clusters_representatives.fasta`.

~~~
# put the representatives names in 'my_clusters_representatives.txt'
$ cut ... > 1_assemblies/separate_assemblies/my_clusters_representatives.txt

# extract the representatives sequences using seqtk
$ seqtk subseq ... > 1_assemblies/separate_assemblies/my_clusters_representatives.fasta
~~~
{: .language-bash}

