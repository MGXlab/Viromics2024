---
title: "Assembly and cross-assembly"
teaching: 120
exercises: 30
questions:
- "many for sure"
objectives:
- "does this work?"
keypoints:
---

# Assembly and cross-assembly

*Sequence assembly* is the reconstruction of long contiguous genomic sequences (called *contigs* or *scaffolds*) from short sequencing reads. Before 2014, a common approach in metagenomics was to compare the short sequencing reads to the genomes of known organisms in the database (and some studies today still take this approach). However, recall that most of the sequences of a metavirome are unknown, meaning that they yield no matches when are compared to the databases. Because of this, we need of database-independent approaches to describe new viral sequences. As bioinformatic tools improved, sequence assembly enabled recovery of longer sequences of the metagenomic datasets. Having a longer sequence means having more information to classify it, so using metagenome assembly helps to characterize complex communities such as the gut microbiome.

In this lesson you will assemble the metaviromes in two different ways using the tool [Flye](https://github.com/mikolmogorov/Flye). Since you work on draco, everything even slightly computationally expensive will be run through slurm. Please organize all the following steps in one or more sbatch scripts as you learned yesterday. Since every tool needs different amounts of resources, it is recommended to have a single script per tool. All code snippets presented here assume that you put them in an adequate sbatch script and the respective necessary resources are mentioned in the comments or the descriptions.

### Cross-Assembly

In a cross-assembly, **multiple samples are combined and assembled together**, allowing for the discovery of shared sequence elements between the samples. If a virus (or other sequence element) is present in several samples, its sequencing reads from the different samples will be assembled together in one contig. After this we can know which contigs are present in which sample by mapping the sequencing reads from each sample to the cross-assembly.

You will perform a cross-assembly of the samples you started working with yesterday. To this end, you have to concatenate the sample files and run flye on the merged file. Gzipped files can be concatenated just like text files with the command line tool cat and flye is installed in a conda environment on draco:

~~~
# merge the sequences
$ cat *.fastq.gz > all_samples.fastq.gz

# create a folder for the output cross-assembly
$ mkdir -p 10_results_assembly_flye/crossassembly

# complete the flye command and run it
$ flye --out-dir 10_results_assembly_flye/crossassembly ...
~~~
{: .language-bash}

Flye can be used for single-organism assemblies as well as metagenomic assemblies. [Here](https://github.com/mikolmogorov/Flye/blob/flye/docs/USAGE.md) you can find an overview over the possible parameters. Remember that your sequences were generated with the MinION platform from nanopore and filtered to only contain high quality reads. Flye needs an estimate of the size of your metagenome, i.e. the combined length of the assembled contigs. There is no good way to accurately predict this if you do not know what's in your samples as in our case. How would you very roughly estimate this number?

### Separate assemblies

The second approach consists on performing separate assemblies for each sample and merging the resulting contigs at the end. Note well if a species is present in several samples, this final set will contain multiple contigs representing the same sequence, each of them coming from one sample. Because of this, we will further de-replicate the final contigs to get representative sequences.

If you wouldn't know how to run the 12 assemblies sequentially with one command, check block below. Else, create a folder `1_assemblies/separate_assemblies` and put each sample's assembly there (ie. `1_assemblies/separate_assemblies/F1M`). Use the same parameters as in the cross-assembly.

> ## Process multiple samples sequentially
> Sometimes you need to do the same analysis for different samples. For those cases,
> instead of waiting for one sample to finish to start off with the next one, you
> can set a command to process all of them sequentially.
>
> First you need to define a variable (ie. SAMPLES) with the name of your samples.
> Then, you can use a `for` loop to iterate the samples and repeat the analysis command,
> which is everything between `;do` and the `;done`. Note well the sample name is just the suffix
> of the input and output and you still need to add the proper directory and file extension.
>
> Let's say you have sequencing reads in the files `sample1.fastq`, `sample2.fastq`
> and `sample3.fastq`, each of them representing a sample. You want to align them
> to a given genome using bowtie2 and save the output to `alignments/sample1_aligned.sam`,
> `alignments/sample2_aligned.sam` and `alignments/sample3_aligned.sam`. You could
> do this:
> ~~~
> # define a variable with the names of the samples
> export SAMPLES="sample1 sample2 sample3"
>
> # iterate the sample names in SAMPLES
> for sample in $SAMPLES; do bowtie2 -x genome_index -1 ${sample}.fastq -S alignments/${sample}_aligned.sam ; done
> ~~~
> {: .language-bash}
{: .objectives}

Once the assemblies had finished, you will combine their scaffolds in a single file.
The identifier of a contig/scaffold from SPAdes has the following format (from the [SPAdes manual](https://cab.spbu.ru/files/release3.15.2/manual.html)): _>NODE_3_length_237403_cov_243.207_, where _3_ is the number of the contig/scaffold, _237403_ is the sequence length in nucleotides and _243.207_ is the k-mer coverage.
It might happen that 2 contigs from different samples' assemblies have the same identifier, and
recall from earlier this morning that
So, just in case, we will add the sample identifier at the beginning of the scaffolds identifiers
to make sure they are different between samples. Use the Python script `rename_scaffolds.py`
for this, which will create a `scaffolds_renamed.fasta` file for each sample's assembly. Then,
merge the results into `1_assemblies/separate_assemblies/all_samples_scaffolds.fasta`.

~~~
# download the python script
$ wget https://raw.githubusercontent.com/MGXlab/Viromics-Workshop-MGX/gh-pages/code/day1/rename_scaffolds.py

# include sample name in scaffolds names
$ python rename_scaffolds.py -d 1_assemblies/separate_assemblies

# merge renamed scaffolds
$ cat 1_assemblies/separate_assemblies/*/scaffolds_renamed.fasta > 1_assemblies/separate_assemblies/all_samples_scaffolds.fasta
~~~
{: .language-bash}

To de-replicate the scaffolds, you will cluster them at 95% Average Nucleotide Identify (ANI) over 85% of the length of the shorter sequence, cutoffs often used to cluster viral genomes at the species level. For further analysis, we will use the longest sequence of the cluster as a representative of it. Then, with this approach we are:

- Clustering complete viral genomes at the species level
- Clustering genome fragments along with very similar and longer sequences

Look at the [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/) website and follow the steps under _Rapid genome clustering based on pairwise ANI_ section to perform this clustering.

~~~


# create a blast database with all the scaffolds
$ makeblastdb ...

# compare the scaffolds all vs all using blastn
$ blastn ...

# download anicalc.py and aniclust.py scripts
$ wget https://raw.githubusercontent.com/MGXlab/Viromics-Workshop-MGX/gh-pages/code/day1/anicalc.py
$ wget https://raw.githubusercontent.com/MGXlab/Viromics-Workshop-MGX/gh-pages/code/day1/aniclust.py

# calculate pairwise ANI
$ python anicalc.py ...

# cluster scaffolds at 95% ANI and 85% aligned fraction of the shorter
$ python aniclust.py -o 1_assemblies/separate_assemblies/my_clusters.tsv ...
~~~
{: .language-bash}


The final output, called `my_clusters.tsv`, is a two-columns tabular file with the representative sequence of the cluster in the first column, and all the scaffolds that are part of the cluster in the second column. Using `cut` and its `-f` parameter to put all the representatives names in one file called `my_clusters_representatives.txt`. Then, use `seqtk subseq` to grab the sequences of the scaffolds listed in `my_clusters_representatives.txt` and save them to `my_clusters_representatives.fasta`.

~~~
# put the representatives names in 'my_clusters_representatives.txt'
$ cut ... > 1_assemblies/separate_assemblies/my_clusters_representatives.txt

# extract the representatives sequences using seqtk
$ seqtk subseq ... > 1_assemblies/separate_assemblies/my_clusters_representatives.fasta
~~~
{: .language-bash}

> ## Scaffolding in SPAdes
> Previously this morning you saw how, using paired-end reads information, contigs
> can be merged in scaffolds. However, we have been using the scaffolds during this  
> lesson.
> Identify a scaffold with clear evidence of merged contigs, and explain how is that
> possible if we are using single-end reads.
> > ## Solution
> > Not the solution, but a hint ;) check the [SPAdes manual](http://cab.spbu.ru/files/release3.15.3/manual.html)
> {: .solution}
{: .challenge}

