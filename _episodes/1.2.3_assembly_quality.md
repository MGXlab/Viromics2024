---
title: "Assessing assembly quality"
teaching: 0
exercises: 120
questions:
objectives:
- "Assess the quality of your assemblies"
keypoints:
- "checkV assesses the quality of your contigs with regard to viral completeness and contamination"
- "minimap2 aligns long and noisy nanopore reads efficiently to large (meta)genomes"
- "samtools can be used to read, filter, convert and summarize alignments"
---

Now we will measure some basic aspects of the assemblies, such as the fragmentation degree and the 
percentage of the raw data they represent. A metagenome consists of all the genomic information of 
all the organisms in a given system. So in the ideal case, a metagenomic assembly would contain a 
single and complete contig for each chromosome or plasmid in the sample, in which case all the 
metagenomic sequencing reads can be perfectly mapped back to the assembly. Of course, this will 
never happen, because in most biomes there is a [long tail of rare organisms](https://www.nature.com/articles/nmeth0909-636/figures/1) 
that contribute only a tiny fraction of the sequenced DNA, so complete horizontal coverage of their 
genome cannot be achieved, and their assembly remains fragmented. Other problems are repeated 
regions in the metagenome and microdiversity between strains, which both lead to complex structures 
in the assembly graph, and thus fragmented assemblies (as discussed yesterday). 

### Estimating genome completeness

There are tools to assess the completeness of bacterial and viral genome sequences. For viruses 
we use [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/). The tool identifies genes 
on the query sequence and compares them to a database of viral and bacterial marker genes. Each 
taxonomic group of bacteria or phages, e.g. a species or a family, has certain marker genes on its 
genome. So based on the number and types of marker genes, CheckV can figure out to which taxon a 
query contig belongs and estimate how much of the genome it represents (estimated completeness). 
(We will improve the taxonomic annotation in the "Viral Taxonomy and Phylogeny" section next week.) 
CheckV also checks for unexpected marker genes on the sequence (estimated contamination), 
and whether part of a phage contig likely represents bacterial sequence, in which case the fragment 
could be part of a host genome with an integrated prophage.

~~~
# create a folder for the assessment (or let sbatch create it when you assign the output and error log files)
$ mkdir 30_results_assessment_checkv

# activate the conda environment containing the checkv installation
$ source /vast/groups/VEO/tools/anaconda3/etc/profile.d/conda.sh && conda activate checkv_v1.0.1

# run checkV on both assemblies
$ checkv end_to_end ...
~~~
{: .language-bash}

> ## sbatch script for running checkV
> ```bash
> #!/bin/bash
> #SBATCH --tasks=1
> #SBATCH --cpus-per-task=22
> #SBATCH --partition=standard
> #SBATCH --mem=20G
> #SBATCH --time=02:30:00
> #SBATCH --job-name=assessment_checkv
> #SBATCH --output=30_results_assessment_checkv/assessment_checkv.slurm.%j.out
> #SBATCH --error=30_results_assessment_checkv/assessment_checkv.slurm.%j.err
> 
> # run CheckV to assess the completeness of single-contig virus genomes.
> # First, activate the conda environment which holds the CheckV installation on draco:
> source /vast/groups/VEO/tools/anaconda3/etc/profile.d/conda.sh && conda activate checkv_v1.0.1
>
> # CheckV parameters (https://bitbucket.org/berkeleylab/checkv/src/master/#markdown-header-running-checkv)
> # checkv end-to-end runs the CheckV pipeline from end to end :). It expects an input fasta file 
> # with the assembly and an output path.
> # -t: threads
> checkv end_to_end -t 20 -d /work/groups/VEO/databases/checkv/v1.5 20_results_dereplication_vclust/cross_assembly/assembly.fasta 30_results_assessment_checkv/cross_assembly
> checkv end_to_end -t 20 -d /work/groups/VEO/databases/checkv/v1.5 20_results_dereplication_vclust/single_assemblies/assembly.fasta 30_results_assessment_checkv/single_assemblies
> 
> # technically its not necessary to close the conda environment, 
> # the session will be terminated after the script finishes.
> conda deactivate
> ```
> {: .source}
{: .solution}

> ## Go through the CheckV results
> CheckV produces many output files, and also saves files for the intermediate steps
> of the tools that are used to find viral marker genes (diamond and hmmsearch).
> A summary of all results can be found in the file `quality_summary.tsv`.
> Open the file and familiarize yourself with the information presented in the table.
> 1. How are completeness and length related? (qualitative answer, name examples)
> 2. What are reasons for contigs with low completeness to appear in the assembly?
> 3. How do completeness and contig coverage relate? (qualitative answer, name examples)
{: .challenge}

### How well does the assembly represent the reads?

Next, we will test how much of the raw data (reads) is represented by the assembly 
(contigs). We will use `minimap2` to align the reads from each sample to the assembled 
contigs. We will map the reads from each barcode separately. Minimap2 is an alignment 
tool that outputs Sequence Alignment Map (SAM) file format, which has to be converted to 
a compressed binary (BAM) format and then sorted using `samtools view` and `samtools sort`. 
You can also use `samtools sort` to create index files, which facilitate access to the 
data in the binary file. Last, you can get basic stats of the mapping using `samtools stats`. 
This will tell you how many of the reads aligned to each of the contigs, and how many did 
not align. You can also pipe the respective outputs of each step into the next step, saving 
disk IO and possibly speeding up things (minimap2 and samtools are specifically designed for 
this). You can read the manuals for [minimap2](https://lh3.github.io/minimap2/minimap2.html)
and [samtools](http://www.htslib.org/doc/samtools.html) to figure out the specific commands
to use (use the solution, if you're short on time).

~~~
# minimap2 and samtools are installed on draco and you can set aliases to their location:
minimap2='/home/groups/VEO/tools/minimap2/v2.26/minimap2'
samtools='/home/groups/VEO/tools/samtools/v1.17/bin/samtools'

# pipe the commands into eachother. The '-'
# tells the tools to take their input from the pipe:
$ $minimap2 ... | $samtools view ... - | $samtools sort ... -

# get mapping statistics of each bam file
$ $samtools stats ...
~~~
{: .language-bash}

`samtools stats` creates a long report with tabular statistics which could be plotted. 
The size of the output is determined by the maximum length of all reads and can get very 
large for alignments of long reads. A summary of the statistics is located at the beginning
of the file and you can read the relevant first 46 lines with "head -46 path/to/stats/file.txt".
There is a lot of information contained in these lines, an important measure for us is the
number of reads which could be mapped back to the assembly and also the number of bases mapped.

> ## sbatch script for aligning the samples to the assemblies
> ```bash
> #!/bin/bash
> #SBATCH --tasks=1
> #SBATCH --cpus-per-task=32
> #SBATCH --partition=standard
> #SBATCH --mem=20G
> #SBATCH --time=00:30:00
> #SBATCH --job-name=alignment_minimap2
> #SBATCH --output=40_results_alignment_minimap2/alignment_minimap2.slurm.%j.out
> #SBATCH --error=40_results_alignment_minimap2/alignment_minimap2.slurm.%j.err
> 
> # assign tool paths to aliases for better readability
> minimap2='/home/groups/VEO/tools/minimap2/v2.26/minimap2'
> samtools='/home/groups/VEO/tools/samtools/v1.17/bin/samtools'
>
> indir='../data/sequences'
> outdir='../data/alignments/cross_assembly'
> mkdir -p $outdir
> 
> # run minimap2 to align all reads from a sample to the assembled contigs
> # and pipe the output into samtools for conversion into the binary bam format
> #
> # minimap2 parameters (https://lh3.github.io/minimap2/minimap2.html):
> # -x map_ont : Use a preset for parameterizing the affine gap penalty model for the extension of matched seeds
> # suited for noisy nanopore reads.
> # -a : output in SAM format
> # -t 30 : run with 30 threads
> #
> # samtools parameters (http://www.htslib.org/doc/samtools.html):
> #
> # samtools view can be used to convert between SAM, BAM and CRAM formats.
> # view -u : output uncompressed binary format (BAM)
> #
> # samtools sort can be used to sort a SAM, BAM or CRAM file. Some tools expect sorted alignments.
> # sort --write-index : output the index of the sorted alignments, can reduce file IO when accessing only a subset of the alignments
> # sort -o : set the output file for the sorted alignments
> #
> # - : the - tells samtools to take the inpute from the pipe (| is the piping operator).
> for barcode in $(seq 62 64) 
> do 
>   $minimap2 -x map-ont -a -t 30  10_results_assembly_flye/cross_assembly/assembly.fasta $indir/barcode$barcode.fastq.gz | \
>     $samtools view -u - | $samtools sort -o $outdir/barcode$barcode.bam --write-index -
>   $samtools stats $outdir/barcode$barcode.bam > $outdir/barcode$barcode_stats.txt
> done
>
> outdir='../data/alignments/single_assemblies/'
> mkdir -p $outdir
> for barcode in $(seq 62 64) 
> do 
>   $minimap2 -x map-ont -a -t 30  20_results_dereplication_vclust/single_assemblies/assembly.fasta $indir/barcode$barcode.fastq.gz | \
>     $samtools view -u - | $samtools sort -o $outdir/barcode$barcode.bam --write-index -
>   $samtools stats $outdir/barcode$barcode.bam > $outdir/barcode$barcode_stats.txt
> done
> ```
> {: .source}
{: .solution}

> ## Compare both assemblies
> You now have access to several metrics about your assemblies.
> {:start="4"}
>   4. The assembly data from Flye;
>   5. The similarity between your contigs from vClust;
>   6. The assessment of completeness and contamination of viral genomes from CheckV;
>   7. The alignment of your reads to the assembled contigs from Minimap2/Samtools.
> 
> Can you summarize these results in a clear way and explain the difference between the
> assemblies? Focus on the difference between the cross-assembly and the separate assemblies.
> Can you think of other metrics to assess the quality of a metagenomic assembly?
{: .challenge}

{% include links.md %}
