---
start: False
title: "Identifying Viral Contigs II"
teaching: 0
exercises: 180
questions: 
objectives:
- "Select medium-complete and low-contaminated contigs"
- "Identify phage contigs in assembled viromes and metagenomes"
- "Interpret Jaeger's output"
- "Select viral contigs for further analysis"
- "Assess assembly completeness"
- "Understand differences between viromes and metagenomes"
keypoints:
- "Filtering contigs by completeness and contamination is crucial to obtain an informative dataset"
- "Tools like Jaeger classify your contigs, enabling you to understand your samples"
- "No wet-lab or dry-lab technique is perfect. Filtering non-viral contigs from your data improves its quality, helping you obtain better results"
---

In this section, we will identify viral sequences among our assembled contigs. This morning, you studied how Wu *et al.* benchmarked nine bioinformatic virus identification tools. As many of those tools are quite slow, we will use a different tool that was developed by the VEO-MGX Groups: [Jaeger](https://github.com/Yasas1994/Jaeger). Jaeger was developed after the Wu *et al.* benchmarking study, so we will test how well it performs ourselves by running it on the cross-assembled virome contig dataset, and also on contigs from total community metagenomes from the same Unterwarnow estuary samples. We will compare the percentage of detected contigs to the numbers reported in the Wu *et al.* paper. 

Document your activities and answer the questions below in your lab book. Do not forget to cite all relevant sources in your work.   

# Filter Contigs by Completeness and Contamination

Before we identify viral contigs in your cross-assembly, we will filter out contigs with too low values of completeness and too high values of contamination. 

> ## Discussion
>
> Why is it important to filter contigs based on values of completeness and contamination?
> 
> {: .source}
{: .discussion}

After you did the [cross-assembly](https://mgxlab.github.io/Viromics2024/1.2.2_assembly_and_cross-assembly/index.html), you used [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/) to predict completeness and contamination of contigs. Today, you will use these values to filter contigs. Go to the tool's website and investigate sections "How it works" and "Output files". As a rule of thumb, you could keep all contigs with completeness >50% and contamination <5%. These values could be changed depending on the data and on the project. Note that filtering for low completeness can remove some conserved regions.   

As you saw in CheckV's website, different outputs are available for you. Therefore, you could apply different strategies to filter the contigs. To make it easier and more straightforward, use the file ```quality_summary.tsv``` to get the completeness and contamination values. If you are an experienced programmer, write (a) script(s) for the filtering. If you are not, use the solutions below. For developing a script, use your local computer with VScode. After your make sure it is working well, run it in Draco with an sbatch script. 

> ## script for filtering complete contigs 
> ```python
> #Input: (i) FASTA file with phage contigs, (ii) CheckV's output
> #Output: FASTA file containing filtered phage contigs (>50% completeness, <5% contamination) 
> 
> import pandas as pd
> 
> #Get name of paths and files of input
> filename_checkv = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.2_virome_assembly/21_results_assessment_checkv/crossassembly/quality_summary.tsv'
> filename_fasta = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.2_virome_assembly/10_results_assembly_flye/crossassembly/assembly.fasta'
> 
> 
> # READ INPUTS ######################
> 
> #Read CheckV file into pandas DataFrame
> df_checkv = pd.read_csv(filename_checkv, sep='\t')
> 
> #Store FASTA file in a list
> tmp = open(filename_fasta, 'r')
> fasta_lst = tmp.readlines()
> #print(fasta_lst[0:10])
> 
> #Define thresholds
> threshold_completeness = 50
> threshold_contamination = 5
> 
> # STORE COMPLETENESS, CONTAMINATION VALUES ###########
> 
> # Initiate dictionary to store contigs and values
> contig2completeness = {}
> 
> # Iterate over each row in the DataFrame
> for index, row in df_checkv.iterrows():
> 
>     # Get values
>     contig_id = row['contig_id']
>     completeness = row['completeness']
>     contamination = row['contamination']
> 
>     # Initiate dictionary
>     contig2completeness[contig_id] = {}
> 
>     #Store into nested dictionary columns contig_id, completeness and contamination of CheckV's output
>     contig2completeness[contig_id]['completeness'] = completeness
>     contig2completeness[contig_id]['contamination'] = contamination
> 
> #print(contig2completeness)
> 
> # FILTER FASTA ####################
> 
> #Create flag for for loop below
> print_lines = False
> 
> #For each line of FASTA file, check header and print FASTA sequence if values are within thresholds
> for line in fasta_lst:
> 
>     #If line is a header, get its ID
>     if(line.startswith('>')):
> 
>         #Set flag to False until it is established that this contig should be kept
>         print_lines = False
> 
>         #Remove '>' and strip whitespace from the line, then store it as the header
>         header = line[1:].strip()
> 
>         #Check if header is contained in CheckV's dictionary, report warning if it is not
>         if contig2completeness[header]:
> 
>             #Get CheckV's values for this header/contig_id
>             header_completeness = contig2completeness[header]['completeness']
>             header_contamination = contig2completeness[header]['contamination']
> 
>             #Check if CheckV report fit within threshold values     
>             if ( (header_completeness >= threshold_completeness) and (header_contamination <= threshold_contamination) ):
>                 #Set flag to True
>                 print_lines = True
> 
>         else:
>             print("Warning:", header, "is not in CheckV's file!")
> 
>     #Print lines of FASTA file if flag is true
>     if print_lines:
>         print(line.strip())
>```
> {: .source}
{: .solution} 

> ## bash command for running script
> ```bash
> python3 filter_contigs_completeness_contamination.py > complete_contigs.fasta
>```
> {: .source}
{: .solution}

> ## Questions
>
> 1. How many contigs did you originally have in the virome cross-assembly?
> 
> 2. How many contigs did you get after filtering for completeness and contamination?
> 
> {: .source}
{: .discussion}

> ## bash command for getting the number of contigs
> ```bash
> grep '>' <file> | wc -l
>```
> {: .source}
{: .solution}

# Identify Viral Contigs

Now that we have a set of at least medium-complete contigs with little contamination, we can continue to identify viral contigs with Jaeger.

> ## Challenge
>
> Viromes and metagenomes are obtained in the wet lab through different filtration steps. Smaller filters remove larger particles such as eukaryotes and prokaryotes. Where do you expect the most hits from Jaeger (virome or metagenome) and why? 
> 
> Why is it important to use tools like Jaeger on viromes?  
> 
> {: .source}
{: .discussion}

Location of metagenome assemblies: ```/work/groups/VEO/shared_data/veo_students/metagenome_XJ/bacterial_assembly_q15.fasta```. Note that Jaeger should require a bit more than 1 GB for the sbatch job, so make sure to allocate at least 2 GB of memory. Jaeger can run on CPU nodes, but it's speed is optimal when run on GPU nodes. In the parameter ```--partition``` of the sbatch script, you could add ```gpu,short``` to allocate the job to a GPU node. 

> ## Exercise
>
> Run Jaeger for viromes and metagenomes:
> - Read and interpret the output following Jaeger's [webpage](https://github.com/Yasas1994/Jaeger?tab=readme-ov-file#what-is-in-the-output)
> 
>```bash
> module load nvidia/cuda/12.1.0
> source /vast/groups/VEO/tools/miniconda3_2024/etc/profile.d/conda.sh
> conda activate jaeger_dev
> python3 /home/groups/VEO/tools/jaeger/v1.1.30a0/Jaeger/bin/jaeger run -i <file> -o <output_file>
>```
>
> - Inspect the output files
>   
>```bash
> head <output>
>```
> {: .source}
{: .challenge}

After running Jaeger, answer the questions below.

> ## Questions
>
> 3. Do the results corroborate your expectations?
> 
> 4. Why are not all contigs in the virome identified as viral contigs?  
>
> 5. Why are viral contigs also identified in the metagenome?  
>
> Optional: How many viral contigs are there in the virome and in the metagenome?
>
> Optional: Take the longest contig from each dataset (virome and metagenome) and [BLAST](https://blast.ncbi.nlm.nih.gov/Blast.cgi) it using blastn. What are the top hits? Are they expected?
>
> Optional: What are the size differences between viral and non-viral contigs? (You could investigate this using a script or visualization)
>
> {: .source}
{: .discussion}

> ## bash command for getting the number of phage contigs
> ```bash
> grep -v <file> | cut -f 3 | sort | uniq -c
>```
> {: .source}
{: .solution}

# Filter contigs

Use Jaeger's predictions of column 3 to separate phage from non-phage contigs. If you are an experienced programmer, write (a) script(s) for that. If you are not, use the solutions below. For the solutions below, we used file ```complete_contigs_default_jaeger.tsv```, however, you could also use ```complete_contigs_default_phages_jaeger.tsv```.

> ## script for selecting viral contigs 
> ```python 
> #Get name of paths and files of input
> filename_jaeger = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.3_virus_identification/10_jaeger/results_jaeger/complete_contigs/complete_contigs_default_jaeger.tsv'
> filename_fasta = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.3_virus_identification/00_complete_contigs/complete_contigs.fasta'
> 
> # READ INPUTS ######################
> 
> #Read Jaeger files into pandas DataFrame
> df_jag = pd.read_csv(filename_jaeger, sep='\t')
> #print(df_jag.head())
> 
> #Store FASTA file in a list
> tmp = open(filename_fasta, 'r')
> fasta_lst = tmp.readlines()
> #print(fasta_lst[0:10])
> 
> # FILTER FASTA ####################
> 
> #Store into list column contig_id of Jaeger's output when prediction column equals "Phage"
> id_lst = df_jag[df_jag['prediction'] == 'phage']['contig_id'].tolist()
> #print(id_lst)
> 
> #Print number of contigs predicted as Phage by Jaeger
> #print(len(id_lst), 'contigs are predicted as "Phage" by Jaeger')
> 
> #Create flag for for loop below
> print_lines = False
> 
> #For each line of FASTA file, check header and print FASTA sequence if ID is contained in id_lst
> for line in fasta_lst:
>     
>     #If line is a header, get its ID
>     if(line.startswith('>')):
>         #Remove '>' and strip whitespace from the line, then store it as the header
>         header = line[1:].strip()
>         #print(header)
> 
>         #Check if header is contained in id_lst, change flag to True
>         if header in id_lst:
>             print_lines = True
>         else:
>             print_lines = False
>     
>     #Print FASTA lines if header@s ID was in id_lst
>     if print_lines:
>         print(line.strip())
>```
> {: .source}
{: .solution} 
{: .challenge}

> ## bash commands for running a script
> ```bash
> python3 select_contigs.py > phage_contigs.fasta
>```
> {: .source}
{: .solution}
> 
