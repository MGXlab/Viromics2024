---
start: True
title: "Identifying Viral Contigs II"
exercises: 180
questions:
objectives:
- "Select medium-complete and low-contaminated contigs"
- "Identify phage contigs in assembled viromes and metagenomes"
- "Interpret Jaeger's output"
- "Select viral contigs for further analysis"
- "Assess assembly completeness"
- "Understand differences between viromes and metagenomes"
keypoints:
- ""
---

In this experimental part, you will identify viruses in your assembled contigs (use the crossassembly). In the morning, you learned about different virus identification tools with a benchmarking paper. Today, you will use a tool that was developed after that benchmarking: [Jaeger](https://github.com/Yasas1994/Jaeger). Jaeger was developed by the VEO-MGX groups. You will run it on the viromes you assembled and also on metagenomes that were produced for the same project (community coalescence). You will do that to compare Jaeger's results for viromes and metagenomes. Document your activites and answer the questions proposed here in your lab book. Do not forget to cite all relevant sources in your work.   

# Filter Contigs by Completeness and Contamination

Before we identify viral contigs in your crossassembly, we will filter out contigs with too low values of completeness and too high values of contamination. 

> ## discussion
>
> Why is it important to filter contigs based on values of completeness and contamination?
> 
> {: .source}
{: .discussion}

After you did the [cross-assembly](https://mgxlab.github.io/Viromics2024/1.2.2_assembly_and_cross-assembly/index.html), you used the tool [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/) to predict completeness and contamination of contigs. Today, you will use these to filter contigs. Go to the tool's website and investigate sections "How it works" and "Output files". As a rule of thumb, you could keep all contigs with completeness >50% and contamination <5%. These values could be changed depending on the data and on the project. For metagenomics and viromics, these values are typically used. 

As you saw in CheckV's website, different outputs are available for you. Therefore, you could apply different strategies to filter the contigs. To make it easier and more straightforward, use file ```quality_summary.tsv``` to get the values of completeness and contamination. If you are an experienced programmer, write (a) script(s) for the filtering. If you are not, use the solutions below.     

> ## bash command for running script
> ```bash
> python3 filter_contigs_completeness_contamination.py > complete_contigs.fasta
>```
> {: .source}
{: .solution}

> ## script for filtering complete contigs 
> ```python
> #Input: (i) FASTA file with phage contigs, (ii) CheckV's output
> #Output: FASTA file containing filtered phage contigs (>50% completeness, <5% contamination) 
> 
> import pandas as pd
> 
> #Get name of paths and files of input
> filename_checkv = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.2_virome_assembly/21_results_assessment_checkv/crossassembly/quality_summary.tsv'
> filename_fasta = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.2_virome_assembly/10_results_assembly_flye/crossassembly/assembly.fasta'
> 
> 
> # READ INPUTS ######################
> 
> #Read CheckV file into pandas DataFrame
> df_checkv = pd.read_csv(filename_checkv, sep='\t')
> 
> #Store FASTA file in a list
> tmp = open(filename_fasta, 'r')
> fasta_lst = tmp.readlines()
> #print(fasta_lst[0:10])
> 
> #Define thresholds
> threshold_completeness = 50
> threshold_contamination = 5
> 
> # STORE COMPLETENESS, CONTAMINATION VALUES ###########
> 
> # Initiate dictionary to store contigs and values
> contig2completeness = {}
> 
> # Iterate over each row in the DataFrame
> for index, row in df_checkv.iterrows():
> 
>     # Get values
>     contig_id = row['contig_id']
>     completeness = row['completeness']
>     contamination = row['contamination']
> 
>     # Initiate dictionary
>     contig2completeness[contig_id] = {}
> 
>     #Store into nested dictionary columns contig_id, completeness and contamination of CheckV's output
>     contig2completeness[contig_id]['completeness'] = completeness
>     contig2completeness[contig_id]['contamination'] = contamination
> 
> #print(contig2completeness)
> 
> # FILTER FASTA ####################
> 
> #Create flag for for loop below
> print_lines = False
> 
> #For each line of FASTA file, check header and print FASTA sequence if values are within thresholds
> for line in fasta_lst:
> 
>     #If line is a header, get its ID
>     if(line.startswith('>')):
> 
>         #Set flag to False until it is established that this contig should be kept
>         print_lines = False
> 
>         #Remove '>' and strip whitespace from the line, then store it as the header
>         header = line[1:].strip()
> 
>         #Check if header is contained in CheckV's dictionary, report warning if it is not
>         if contig2completeness[header]:
> 
>             #Get CheckV's values for this header/contig_id
>             header_completeness = contig2completeness[header]['completeness']
>             header_contamination = contig2completeness[header]['contamination']
> 
>             #Check if CheckV report fit within threshold values     
>             if ( (header_completeness >= threshold_completeness) and (header_contamination <= threshold_contamination) ):
>                 #Set flag to True
>                 print_lines = True
> 
>         else:
>             print("Warning:", header, "is not in CheckV's file!")
> 
>     #Print lines of FASTA file if flag is true
>     if print_lines:
>         print(line.strip())
>```
> {: .source}
{: .solution} 

> ## discussion
>
> How many contigs did you have originally in the cross-assembly?
> 
> How many contigs have you got after filtering for completeness and contamination?
> 
> {: .source}
{: .discussion}

> ## bash command for getting number of contigs
> ```bash
> grep -v 'contig_id' <file> | wc -l
>```
> {: .source}
{: .solution}

# Identify Viral Contigs

Now that you have a set of medium-complete contigs with little contamination, follow to identify viral contigs with Jaeger.

> ## discussion
>
> Viromes and metagenomes are prepared differently in the wet lab. Each has their purpose. Where do you expect the most hits from Jaeger (virome or metagenome) and why? 
> 
> Why is it important to use tools like Jaeger on viromes?  
> 
> {: .source}
{: .discussion}

Location of metagenome assemblies: ```/work/groups/VEO/shared_data/veo_students/metagenome_XJ/bacterial_assembly_q15.fasta```

> ## exercise
>
> Run Jaeger for viromes and metagenomes:
> - read and interpret the output following Jaeger's [webpage](https://github.com/Yasas1994/Jaeger?tab=readme-ov-file#what-is-in-the-output)
> 
>```bash
> source /vast/groups/VEO/tools/anaconda3/etc/profile.d/conda.sh
> conda activate jaeger_v1.31.0
> Jaeger -i <file> -o <output_file>
>```
>
> - inspect the output
>   
>```bash
> head <output>
>```
> {: .source}
{: .challenge}

After running Jaeger, answer the questions below.

> ## discussion
>
> do the results corroborate your expectations?
> 
> why are not all contigs in the virome identified as viral contigs?  
>
> why are viral contigs also identified in the metagenome?  
>
> optional: how many viral contigs are there in the virome and in the metagenome?
>
> optional: take the longest contig from each dataset (virome and metagenome) and BLAST it (link below). What are the top hits? Are they expected?
>
> optional: what are the size differences between viral and non-viral contigs? (You could investigate this using a script or visualization)
>
> {: .source}
{: .discussion}

# Filter Contigs

Use Jaeger's predictions of column 7 to separate phage from non-phage contigs. If you are an experienced programmer, write (a) script(s) for that. If you are not, use the solutions below.   

> ## bash commands for running a script
> ```bash
> python3 select_contigs.py > phage_contigs.fasta
>```
> {: .source}
{: .solution}

> ## script for selecting viral contigs 
> ```python 
> #Get name of paths and files of input
> filename_jaeger = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.3_virus_identification/00_jaeger/results_jaeger/assembly_jaeger.tsv'
> filename_fasta = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.2_virome_assembly/10_results_assembly_flye/crossassembly/assembly.fasta'
> 
> # READ INPUTS ######################
> 
> #Read Jaeger files into pandas DataFrame
> df_jag = pd.read_csv(filename_jaeger, sep='\t')
> #print(df_jag.head())
> 
> #Store FASTA file in a list
> tmp = open(filename_fasta, 'r')
> fasta_lst = tmp.readlines()
> #print(fasta_lst[0:10])
> 
> # FILTER FASTA ####################
> 
> #Store into list column contig_id of Jaeger's output when prediction column equals "Phage"
> id_lst = df_jag[df_jag['prediction'] == 'Phage']['contig_id'].tolist()
> #print(id_lst)
> 
> #Print number of contigs predicted as Phage by Jaeger
> #print(len(id_lst), 'contigs are predicted as "Phage" by Jaeger')
> 
> #Create flag for for loop below
> print_lines = False
> 
> #For each line of FASTA file, check header and print FASTA sequence if ID is contained in id_lst
> for line in fasta_lst:
>     
>     #If line is a header, get its ID
>     if(line.startswith('>')):
>         #Remove '>' and strip whitespace from the line, then store it as the header
>         header = line[1:].strip()
>         #print(header)
> 
>         #Check if header is contained in id_lst, change flag to True
>         if header in id_lst:
>             print_lines = True
>         else:
>             print_lines = False
>     
>     #Print FASTA lines if header@s ID was in id_lst
>     if print_lines:
>         print(line.strip())
>```
> {: .source}
{: .solution} 

# Assess Completeness

After selecting phage contigs and saving them to (a) new FASTA file(s), assess the genome completeness of the contigs. For this you will use [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/).     

> ## exercise
>
> Run CheckV:
> - read and interpret the output following CheckV's webpage.
> 
>```bash
> source /vast/groups/VEO/tools/anaconda3/etc/profile.d/conda.sh && conda activate checkv_v1.0.1 && checkv -h
> checkv completeness ? -d /work/groups/VEO/databases/checkv/v1.5 ?
>```
>
> - inspect the output
>   
>```bash
> head <output>
>```
>
> {: .source}
{: .challenge}

# Resources

- [Link for BLAST](https://blast.ncbi.nlm.nih.gov/Blast.cgi)
