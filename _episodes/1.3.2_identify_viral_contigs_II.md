---
start: False
title: "Identifying viral contigs II"
teaching: 0
exercises: 180
questions: 
objectives:
- "Select medium-complete and low-contaminated contigs"
- "Identify phage contigs in assembled viromes and metagenomes"
- "Interpret Jaeger's output"
- "Select viral contigs for further analysis"
- "Assess assembly completeness"
- "Understand differences between viromes and metagenomes"
keypoints:
- "Filtering contigs by completeness and contamination is crucial to obtain an informative dataset"
- "Tools like Jaeger classify your contigs, enabling you to understand your samples"
- "No wet-lab or dry-lab technique is perfect. Filtering non-viral contigs from your data improves its quality, helping you obtain better results"
---

In this section, we will identify viral sequences among our assembled contigs. This morning, you studied how Wu *et al.* benchmarked nine bioinformatic virus identification tools. As many of those tools are quite slow, we will use a different tool that was developed by the VEO-MGX Groups: [Jaeger](https://github.com/Yasas1994/Jaeger). Jaeger was developed after the Wu *et al.* benchmarking study, so we will test how well it performs ourselves by running it on the cross-assembled virome contig dataset, and also on contigs from total community metagenomes from the same Unterwarnow estuary samples. We will compare the percentage of detected contigs to the numbers reported in the Wu *et al.* paper. 

Document your activities and answer the questions below in your lab book. Do not forget to cite all relevant sources in your work.   

# Identify viral contigs

We will start to identify viral contigs with Jaeger.

> ## Challenge
>
> Viromes and metagenomes are obtained in the wet lab through different filtration steps. Smaller filters remove larger particles such as eukaryotes and prokaryotes. Where do you expect the most hits from Jaeger (virome or metagenome) and why? 
> 
> Why is it important to use tools like Jaeger on viromes?  
> 
> {: .source}
{: .discussion}

Location of metagenome assemblies: ```/work/groups/VEO/shared_data/veo_students/metagenome_XJ/bacterial_assembly_q15.fasta```. Note that Jaeger should require a bit more than 1 GB for the sbatch job, so make sure to allocate at least 2 GB of memory. Jaeger can run on CPU nodes, but it's speed is optimal when run on GPU nodes. In the parameter ```--partition``` of the sbatch script, you could add ```gpu,short``` to allocate the job to a GPU node. 

> ## Exercise
>
> Run Jaeger for viromes and metagenomes:
> - Read and interpret the output following Jaeger's [webpage](https://github.com/Yasas1994/Jaeger?tab=readme-ov-file#what-is-in-the-output)
> 
>```bash
> module load nvidia/cuda/12.1.0
> source /vast/groups/VEO/tools/miniconda3_2024/etc/profile.d/conda.sh
> conda activate jaeger_dev
> python3 /home/groups/VEO/tools/jaeger/v1.1.30a0/Jaeger/bin/jaeger run -i <file> -o <output_file>
>```
>
> - Inspect the output files
>   
>```bash
> head <output>
>```
> {: .source}
{: .challenge}

After running Jaeger, answer the questions below.

> ## Questions
>
> 3. Do the results corroborate your expectations?
> 
> 4. Why are not all contigs in the virome identified as viral contigs?  
>
> 5. Why are viral contigs also identified in the metagenome?  
>
> Optional: How many viral contigs are there in the virome and in the metagenome?
>
> Optional: Take the longest contig from each dataset (virome and metagenome) and [BLAST](https://blast.ncbi.nlm.nih.gov/Blast.cgi) it using blastn. What are the top hits? Are they expected?
>
> Optional: What are the size differences between viral and non-viral contigs? (You could investigate this using a script or visualization)
>
> {: .source}
{: .discussion}

> ## bash command for getting the number of phage contigs
> ```bash
> grep -v <file> | cut -f 3 | sort | uniq -c
>```
> {: .source}
{: .solution}

# Estimating genome completeness

There are tools to assess the completeness of bacterial and viral genome sequences. For viruses 
we use [CheckV](https://bitbucket.org/berkeleylab/checkv/src/master/). The tool identifies genes 
on the query sequence and compares them to a database of viral and bacterial marker genes. Each 
taxonomic group of bacteria or phages, e.g. a species or a family, has certain marker genes on its 
genome. So based on the number and types of marker genes, CheckV can figure out to which taxon a 
query contig belongs and estimate how much of the genome it represents (estimated completeness). 
(We will improve the taxonomic annotation in the "Viral Taxonomy and Phylogeny" section next week.) 
CheckV also checks for unexpected marker genes on the sequence (estimated contamination), 
and whether part of a phage contig likely represents bacterial sequence, in which case the fragment 
could be part of a host genome with an integrated prophage.

~~~
# create a folder for the assessment (or let sbatch create it when you assign the output and error log files)
$ mkdir 30_results_assessment_checkv

# activate the conda environment containing the checkv installation
$ source /vast/groups/VEO/tools/anaconda3/etc/profile.d/conda.sh && conda activate checkv_v1.0.1

# run checkV on both assemblies
$ checkv end_to_end ...
~~~
{: .language-bash}

> ## sbatch script for running checkV
> ```bash
> #!/bin/bash
> #SBATCH --tasks=1
> #SBATCH --cpus-per-task=22
> #SBATCH --partition=standard
> #SBATCH --mem=20G
> #SBATCH --time=02:30:00
> #SBATCH --job-name=assessment_checkv
> #SBATCH --output=30_results_assessment_checkv/assessment_checkv.slurm.%j.out
> #SBATCH --error=30_results_assessment_checkv/assessment_checkv.slurm.%j.err
> 
> # run CheckV to assess the completeness of single-contig virus genomes.
> # First, activate the conda environment which holds the CheckV installation on draco:
> source /vast/groups/VEO/tools/anaconda3/etc/profile.d/conda.sh && conda activate checkv_v1.0.1
>
> # CheckV parameters (https://bitbucket.org/berkeleylab/checkv/src/master/#markdown-header-running-checkv)
> # checkv end-to-end runs the CheckV pipeline from end to end :). It expects an input fasta file 
> # with the assembly and an output path.
> # -t: threads
> checkv end_to_end -t 20 -d /work/groups/VEO/databases/checkv/v1.5 20_results_dereplication_vclust/cross_assembly/assembly.fasta 30_results_assessment_checkv/cross_assembly
> checkv end_to_end -t 20 -d /work/groups/VEO/databases/checkv/v1.5 20_results_dereplication_vclust/single_assemblies/assembly.fasta 30_results_assessment_checkv/single_assemblies
> 
> # technically its not necessary to close the conda environment, 
> # the session will be terminated after the script finishes.
> conda deactivate
> ```
> {: .source}
{: .solution}

> ## Go through the CheckV results
> CheckV produces many output files, and also saves files for the intermediate steps
> of the tools that are used to find viral marker genes (diamond and hmmsearch).
> A summary of all results can be found in the file `quality_summary.tsv`.
> Open the file and familiarize yourself with the information presented in the table.
> 1. How are completeness and length related? (qualitative answer, name examples)
> 2. What are reasons for contigs with low completeness to appear in the assembly?
> 3. How do completeness and contig coverage relate? (qualitative answer, name examples)
{: .challenge}

# Filter contigs

Use Jaeger's predictions of column 3 to separate phage from non-phage contigs. If you are an experienced programmer, write (a) script(s) for that. If you are not, use the solutions below. For the solutions below, we used file ```complete_contigs_default_jaeger.tsv```, however, you could also use ```complete_contigs_default_phages_jaeger.tsv```.

> ## script for selecting viral contigs 
> ```python 
> #Get name of paths and files of input
> filename_jaeger = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.3_virus_identification/10_jaeger/results_jaeger/complete_contigs/complete_contigs_default_jaeger.tsv'
> filename_fasta = '/work/groups/VEO/shared_data/Viromics2024Workspace/1.3_virus_identification/00_complete_contigs/complete_contigs.fasta'
> 
> # READ INPUTS ######################
> 
> #Read Jaeger files into pandas DataFrame
> df_jag = pd.read_csv(filename_jaeger, sep='\t')
> #print(df_jag.head())
> 
> #Store FASTA file in a list
> tmp = open(filename_fasta, 'r')
> fasta_lst = tmp.readlines()
> #print(fasta_lst[0:10])
> 
> # FILTER FASTA ####################
> 
> #Store into list column contig_id of Jaeger's output when prediction column equals "Phage"
> id_lst = df_jag[df_jag['prediction'] == 'phage']['contig_id'].tolist()
> #print(id_lst)
> 
> #Print number of contigs predicted as Phage by Jaeger
> #print(len(id_lst), 'contigs are predicted as "Phage" by Jaeger')
> 
> #Create flag for for loop below
> print_lines = False
> 
> #For each line of FASTA file, check header and print FASTA sequence if ID is contained in id_lst
> for line in fasta_lst:
>     
>     #If line is a header, get its ID
>     if(line.startswith('>')):
>         #Remove '>' and strip whitespace from the line, then store it as the header
>         header = line[1:].strip()
>         #print(header)
> 
>         #Check if header is contained in id_lst, change flag to True
>         if header in id_lst:
>             print_lines = True
>         else:
>             print_lines = False
>     
>     #Print FASTA lines if header@s ID was in id_lst
>     if print_lines:
>         print(line.strip())
>```
> {: .source}
{: .solution} 
{: .challenge}

> ## bash commands for running a script
> ```bash
> python3 select_contigs.py > phage_contigs.fasta
>```
> {: .source}
{: .solution}
> 
